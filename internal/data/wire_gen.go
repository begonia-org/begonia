// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package data

import (
	"github.com/begonia-org/begonia/internal/biz"
	"github.com/begonia-org/begonia/internal/biz/endpoint"
	"github.com/begonia-org/begonia/internal/biz/file"
	"github.com/begonia-org/begonia/internal/pkg/config"
	"github.com/begonia-org/go-sdk/logger"
	"github.com/spark-lence/tiga"
	"time"
)

// Injectors from wire.go:

func NewAppRepo(cfg *tiga.Configuration, log logger.Logger) biz.AppRepo {
	mySQLDao := NewMySQL(cfg)
	configConfig := config.NewConfig(cfg)
	curd := NewCurdImpl(mySQLDao, configConfig)
	redisDao := NewRDB(cfg)
	layeredCache := NewLayeredCache(redisDao, configConfig, log)
	appRepo := NewAppRepoImpl(curd, layeredCache, configConfig)
	return appRepo
}

func NewEndpointRepo(cfg *tiga.Configuration, log logger.Logger) endpoint.EndpointRepo {
	mySQLDao := NewMySQL(cfg)
	redisDao := NewRDB(cfg)
	etcdDao := NewEtcd(cfg)
	data := NewData(mySQLDao, redisDao, etcdDao)
	configConfig := config.NewConfig(cfg)
	endpointRepo := NewEndpointRepoImpl(data, configConfig)
	return endpointRepo
}

func NewAuthzRepo(cfg *tiga.Configuration, log logger.Logger) biz.AuthzRepo {
	redisDao := NewRDB(cfg)
	configConfig := config.NewConfig(cfg)
	layeredCache := NewLayeredCache(redisDao, configConfig, log)
	bizAuthzRepo := NewAuthzRepoImpl(log, layeredCache)
	return bizAuthzRepo
}

func NewUserRepo(cfg *tiga.Configuration, log logger.Logger) biz.UserRepo {
	mySQLDao := NewMySQL(cfg)
	redisDao := NewRDB(cfg)
	etcdDao := NewEtcd(cfg)
	data := NewData(mySQLDao, redisDao, etcdDao)
	configConfig := config.NewConfig(cfg)
	layeredCache := NewLayeredCache(redisDao, configConfig, log)
	curd := NewCurdImpl(mySQLDao, configConfig)
	userRepo := NewUserRepoImpl(data, layeredCache, curd, configConfig)
	return userRepo
}

func NewLayered(cfg *tiga.Configuration, log logger.Logger) *LayeredCache {
	redisDao := NewRDB(cfg)
	configConfig := config.NewConfig(cfg)
	layeredCache := NewLayeredCache(redisDao, configConfig, log)
	return layeredCache
}

func NewOperator(cfg *tiga.Configuration, log logger.Logger) biz.DataOperatorRepo {
	mySQLDao := NewMySQL(cfg)
	redisDao := NewRDB(cfg)
	etcdDao := NewEtcd(cfg)
	data := NewData(mySQLDao, redisDao, etcdDao)
	configConfig := config.NewConfig(cfg)
	curd := NewCurdImpl(mySQLDao, configConfig)
	layeredCache := NewLayeredCache(redisDao, configConfig, log)
	appRepo := NewAppRepoImpl(curd, layeredCache, configConfig)
	userRepo := NewUserRepoImpl(data, layeredCache, curd, configConfig)
	bizAuthzRepo := NewAuthzRepoImpl(log, layeredCache)
	bizDataOperatorRepo := NewDataOperatorRepo(data, appRepo, userRepo, bizAuthzRepo, layeredCache, log)
	return bizDataOperatorRepo
}

func NewDataRepo(cfg *tiga.Configuration, log logger.Logger) *Data {
	mySQLDao := NewMySQL(cfg)
	redisDao := NewRDB(cfg)
	etcdDao := NewEtcd(cfg)
	data := NewData(mySQLDao, redisDao, etcdDao)
	return data
}

func NewLocker(cfg *tiga.Configuration, log logger.Logger, key string, ttl time.Duration, retry int) biz.DataLock {
	redisDao := NewRDB(cfg)
	client := GetRDBClient(redisDao)
	bizDataLock := NewDataLock(client, key, ttl, retry)
	return bizDataLock
}

func NewFileRepo(cfg *tiga.Configuration, log logger.Logger) file.FileRepo {
	mySQLDao := NewMySQL(cfg)
	redisDao := NewRDB(cfg)
	etcdDao := NewEtcd(cfg)
	data := NewData(mySQLDao, redisDao, etcdDao)
	configConfig := config.NewConfig(cfg)
	curd := NewCurdImpl(mySQLDao, configConfig)
	fileRepo := NewFileRepoImpl(data, curd)
	return fileRepo
}
